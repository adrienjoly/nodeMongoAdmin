var mongo = require('mongodb');
var Collection = require('./Collection').Collection;
var Set = require('./Set').Set;

//==============================================================================
exports.open = function(dbName, host, port) {

  host = host || 'localhost';
  port = port || 27017;

  var db;
  var collections = {};
  var collectionsInit = {};
  var Collections = {};
  var pendingQueries = {};
  var sets = {};  

  //============================================================================
  var DB = function(collectionName, query, options) {

    var set;

    if (typeof collectionName === 'string') {
      var collection = collections[collectionName];      
      if (!collection) {        
        if (!pendingQueries[collectionName])
          pendingQueries[collectionName] = [];
        if (!sets[collectionName])
          sets[collectionName] = [];
        if (query || options) {
          set = new Set(null, query, options, pendingQueries[collectionName]);
        } else {
          set = Collections[collectionName] =
              new Collection(null, pendingQueries[collectionName]);
        }
        sets[collectionName].push(set);        
        if (!collectionsInit[collectionName]) {
          var collectionHandler = function(err, collection) {
            if (err) throw err;
            collectionReady(collection, collectionName);
          }
          if (db) {
            db.collection(collectionName, collectionHandler);
          } else {
            new mongo.Db(dbName, new mongo.Server(host, port, {}), {
              native_parser: false
            }).open(function(err, openDb) {
              if (err) throw err;
              db = openDb;
              db.collection(collectionName, collectionHandler);
            });
          }  
          collectionsInit[collectionName] = true;
        }        
      } else {
        set = (query || options) ?
          new Set(collection, query, options) :
          Collections[collectionName];          
      }
      return set;
    }

    else {
      var queries = arguments[0];
      var callback = arguments[1];
      var errorHandler = arguments[2];
      var returnData = {};
      var pending = 0;
      var db = arguments.callee;
      var returnName, q, method;
      var generateHandler = function(returnName) {
        return function(x) {          
          returnData[returnName] = x;
          pending--;
          if (!pending)
            callback(returnData);  
        }
      }
      for (returnName in queries)
        pending++;      
      for (returnName in queries) {
        q = queries[returnName];
        if (q[q.length - 1] === 'findOne') {
          q.pop();
          method = 'one';
        } else {
          method = 'all';
        }
        set = db.apply(db, q);
        set[method](generateHandler(returnName), errorHandler);
      }
    }
    
    return null;
    
  }

  //============================================================================
  var collectionReady = function(collection, collectionName) {
    var collectionQueries = pendingQueries[collectionName];
    var collectionSets = sets[collectionName];
    var i, len, q, set;
    for (i = 0, len = collectionQueries.length; i < len; i++) {
      q = collectionQueries[i];
      collection[q.pop()].apply(collection, q);
    }
    for (i = 0, len = collectionSets.length; i < len; i++) {
      set = collectionSets[i];
      set.collection = collection;
      set.pendingQueries.length = 0;
      delete set.pendingQueries;
    }
    collections[collectionName] = collection;
    collectionQueries.length = 0;
    collectionSets.length = 0;
    delete pendingQueries[collectionName];
    delete sets[collectionName];
    delete collectionsInit[collectionName];
  }

  //============================================================================
  return DB;

}

function multiQuery(q) {
  for (var i = 0; i < q.length; i++) {
    if (q[i].returnAs !== undefined) {

    }
  }
}

function query(q, db, Return, $, count) {
  var callback, e, multi, update, collection, method;
  if (q.returnAs !== undefined) {
    count.lock++;
    callback = function(x) {      
      $[q.returnAs] = x;
      count.lock--;
      if (!count.lock)
        Return($);
    }
  }
  if (!callback && (q.find || q.findOne)) {
    count.lock++;
    callback = function(e) {
      for (var x in e)
        $[x] = e[x];
      count.lock--;
      if (!count.lock)
        Return($);
    }
  }  
  if (q.insert) {
    db(q.collection).insert(q.insert, callback);
  } else if (q.remove) {
    db(q.collection).remove(q.remove, callback);
  } else if (q.save) {
    db(q.collection).save(q.remove, callback);
  } else if ((update = q.update || getUpdates(q))) {
    if (q.element) {
      e = q.element;
      multi = false;
    }
    if (q.elements) {
      e = q.elements;
      multi = true;
    }
    db(q.collection, e).update(update, {
      multi: multi,
      upsert: q.upsert === undefined ? true : q.upsert
    }, callback);
  } else {
    collection = q.collection;    
    delete q.collection;
    if (q.element) {
      e = q.element;
      method = 'one';
      delete q.element;
    }
    if (q.elements) {
      e = q.elements;
      method = 'all';
      delete q.elements;
    }
    if (e)
      db(collection, e)[method](callback);
  }
}


//==============================================================================


