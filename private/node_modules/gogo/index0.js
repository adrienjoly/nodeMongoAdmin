var mongo = require('mongodb');

//==============================================================================
exports.open = function(dbName, host, port) {

  var db;
  var collections = {};
  var pendingQueries = {};
  var subsets = {};

  host = host || 'localhost';
  port = port || 27017;

  return function(collectionName, query, options) {

    var subset;

    if (typeof collectionName === 'string') {
      var collection = collections[collectionName];      
      if (!collection) {
        var collectionHandler = function(err, collection) {
          collectionReady(collection, collectionName, collections,
              pendingQueries, subsets);
        }
        if (!pendingQueries[collectionName])
          pendingQueries[collectionName] = [];
        if (!subsets[collectionName])
          subsets[collectionName] = [];
        subset = new Subset(collection, query, options, pendingQueries[collectionName]);
        subsets[collectionName].push(subset);
        if (db) {
          db.collection(collectionName, collectionHandler);
        } else {
          new mongo.Db(dbName, new mongo.Server(host, port, {}), {
            native_parser: false
          }).open(function(err, openDb) {
            db = openDb;
            db.collection(collectionName, collectionHandler);
          });
        }
      } else {
        subset = new Subset(collection, query, options);
      }
      return subset;
    }

    else {
      var queries = arguments[0];
      var callback = arguments[1];
      var errorHandler = arguments[2];
      var returnData = {};
      var pending = 0;
      var db = arguments.callee;
      var returnName, q, method;
      var generateHandler = function(returnName) {
        return function(err, x) {
          if (err) {
            if (errorHandler) errorHandler(err);
          } else {
            returnData[returnName] = x;
            pending--;
            if (!pending)
              callback(returnData);  
          }
        }
      }
      for (returnName in queries)
        pending++;      
      for (returnName in queries) {
        q = queries[returnName];        
        method = q[q.length - 1] === 'findOne' ? q.pop() : 'find';
        subset = db.apply(db, q);
        subset[method](generateHandler(returnName), errorHandler);        
      }
    }
    
    return null;
    
  }
  
}

//==============================================================================
function collectionReady(collection, collectionName, collections, pendingQueries, subsets) {
  var collectionQueries = pendingQueries[collectionName];
  var collectionSubsets = subsets[collectionName];
  var i, len, q;
  for (i = 0, len = collectionQueries.length; i < len; i++) {
    q = collectionQueries[i];
    collection[q.pop()].apply(collection, q);
  }
  for (i = 0, len = collectionSubsets.length; i < len; i++) {
    collectionSubsets[i].collection = collection;
    delete collectionSubsets[i].pendingQueries;
  }
  collections[collectionName] = collection;
  collectionQueries.length = 0;
  collectionSubsets.length = 0;
  delete pendingQueries[collectionName];
  delete subsets[collectionName];
}

//==============================================================================
function Subset(collection, query, options, pendingQueries) {
  this.collection = collection;
  this.query = query;
  if (pendingQueries) {
    this.pendingQueries = pendingQueries;
  }
  if (options) {
    if (typeof options === 'number') {
      this.options = {limit: options};
    } else if (Array.isArray(options)) {
      this.options = {skip: options[0], limit: options[1] - options[0] + 1};
    } else if (options.fields) {
      if (Array.isArray(options.fields)) {
        this.fields = {};
        for (var i = 0, field; field = options.fields[i]; i++)
          this.fields[field] = 1;
      } else {
        this.fields = options.fields;
      }
      delete options.fields;
    }
  }  
}

//==============================================================================
Subset.prototype.one = function(callback, errorHandler) {
  var handler = function(err, elt) {
    if (err) {
      if (errorHandler) errorHandler(err);
    } else {
      callback(elt);
    }
  }
  this.query = this.query || {};
  this.options = this.options || {};  
  if (this.fields) {
    if (this.collection)
      this.collection.findOne(this.query, this.fields, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.fields, this.options, handler, 'findOne']
      );    
  } else {
    if (this.collection)
      this.collection.findOne(this.query, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.options, handler, 'findOne']
      );    
  }
  return this;
}

//==============================================================================
Subset.prototype.all = function(callback, errorHandler) {
  var handler = function(err, cursor) {
    if (err) {
      if (errorHandler) errorHandler(err);
    } else {
      cursor.toArray(function(err, elts) {
        if (err) {
          if (errorHandler) errorHandler(err);
        } else {
          callback(elts);
        }
      });
    }
  }
  this.query = this.query || {};
  this.options = this.options || {};
  if (this.fields) {
    if (this.collection)
      this.collection.find(this.query, this.fields, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.fields, this.options, handler, 'find']
      );
  } else {
    if (this.collection)
      this.collection.find(this.query, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.options, handler, 'find']
      );
  }
  return this;
}

//==============================================================================
Subset.prototype.each = function(callback, errorHandler) {
  var handler = function(err, cursor) {
    if (err) {
      if (errorHandler) errorHandler(err);
    } else {
      cursor.each(function(err, elt) {
        if (err) {
          if (errorHandler) errorHandler(err);
        } else {
          if (elt)
            callback(elt);
        }
      });
    }
  }
  this.query = this.query || {};
  this.options = this.options || {};
  if (this.fields) {
    if (this.collection)
      this.collection.find(this.query, this.fields, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.fields, this.options, handler, 'find']
      );
  } else {
    if (this.collection)
      this.collection.find(this.query, this.options, handler);
    else
      this.pendingQueries.push(
        [this.query, this.options, handler, 'find']
      );
  }
  return this;
}

//==============================================================================
Subset.prototype.insert = function(elements, callback, errorHandler) {
  if (!Array.isArray(elements) && callback && typeof callback !== 'function') {    
    elements = [elements];
    for (var i = 1; i < arguments.length; i++) {
      if (arguments[i] && typeof arguments[i] !== 'function')
        elements.push(arguments[i]);
      else
        break;
    }    
    callback = arguments[i];
    errorHandler = arguments[i + 1];
  }
  if (callback || errorHandler) {
    var handler = function(err, elts) {
      if (err) {
        if (errorHandler) errorHandler(err);
      } else {
        if (callback)
          callback(elts);
      }
    }
  }
  if (this.collection) {
    handler ?
      this.collection.insert(elements, {safe: true}, handler) :
      this.collection.insert(elements);
  } else {
    this.pendingQueries.push(handler ?
      [elements, handler, 'insert'] :
      [elements, 'insert']
    );
  }
  return this;
}

//==============================================================================
Subset.prototype.remove = function(query, callback, errorHandler) {
  if (typeof query === 'function') {
    errorHandler = callback;
    callback = query;
    query = {};
  }
  if (callback || errorHandler) {
    var handler = function(err, collection) {
      if (err) {
        if (errorHandler) errorHandler(err);
      } else {
        if (callback) callback(collection);
      }
    }  
  }
  query = query || {};
  if (this.collection) {
    handler ?
      this.collection.remove(query, handler) :
      this.collection.remove(query);
  } else {
    this.pendingQueries.push(handler ?
      [query, handler, 'remove'] :
      [query, null, 'remove']
    );
  }
  return this;
}

//==============================================================================
Subset.prototype.save = function(element, callback, errorHandler) {
   if (callback || errorHandler) {
    var handler = function(err, savedElement) {
      if (err) {
        if (errorHandler) errorHandler(err);
      } else {
        if (callback) callback(savedElement);
      }
    }
  }
  if (this.collection) {
    handler ?
      this.collection.save(element, handler) :
      this.collection.save(element);
  } else {
    this.pendingQueries.push(handler ?
      [element, handler, 'save'] :
      [element, 'save']
    );
  }
  return this;
}


//==============================================================================
Subset.prototype.update = function(updateObj, options, callback, errorHandler) {
  this.query = this.query || {};
  if (typeof options === 'function') {
    callback = options;
    errorHandler = callback;
    options = {upsert: false, multi: false};
  }
  if (callback || errorHandler) {
    var handler = function(err) {
      if (err) {
        if (errorHandler) errorHandler(err);
      } else {
        if (callback) callback();
      }
    }
  }
  if (!options) {
    options = {upsert: false, multi: false};
  }
  if (errorHandler) {
    options.safe = true;
  }
  if (this.collection) {
    handler ?
      this.collection.update(this.query, updateObj, options, handler) :
      this.connection.update(this.query, updateObj, options);
  } else {
    this.pendingQueries.push(handler ?
      [this.query, updateObj, options, handler, 'update'] :
      [this.query, updateObj, options, 'update']
    );
  }
  return this;
}

//==============================================================================
Subset.prototype.inc = function(incObj, errorHandler) {
  this.update({$inc: incObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.set = function(setObj, errorHandler) {
  this.update({$set: setObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.unset = function(unsetObj, errorHandler) {
  this.update({$unset: unsetObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.push = function(pushObj, errorHandler) {
  this.update({$push: pushObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.pushAll = function(pushAllObj, errorHandler) {
  this.update({$pushAll: pushAllObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.addToSet = function(addToSetObj, errorHandler) {
  this.update({$addToSet: addToSetObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.pop = function(popObj, errorHandler) {
  this.update({$pop: popObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

Subset.prototype.pull = function(pullObj, errorHandler) {
  this.update({$pull: pullObj}, {upsert: false, multi: false}, errorHandler);
  return this;
}

//==============================================================================
Subset.prototype.multiInc = function(incObj, errorHandler) {
  this.update({$inc: incObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiSet = function(setObj, errorHandler) {
  this.update({$set: setObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiUnset = function(unsetObj, errorHandler) {
  this.update({$unset: unsetObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiPush = function(pushObj, errorHandler) {
  this.update({$push: pushObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiPushAll = function(pushAllObj, errorHandler) {
  this.update({$pushAll: pushAllObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiAddToSet = function(addToSetObj, errorHandler) {
  this.update({$addToSet: addToSetObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiPop = function(popObj, errorHandler) {
  this.update({$pop: popObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}

Subset.prototype.multiPull = function(pullObj, errorHandler) {
  this.update({$pull: pullObj}, {upsert: false, multi: true}, errorHandler);
  return this;
}