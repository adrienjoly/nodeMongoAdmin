var mongo = require('mongodb');
var Collection = require('./Collection').Collection;
var Set = require('./Set').Set;

//==============================================================================
exports.open = function(dbName, host, port) {

  host || (host = 'localhost');
  port || (port = 27017);

  var db;
  var collections = {};
  var collectionsInit = {};
  var Collections = {};  
  var sets = {};
  var pendingQueries = {};

  //============================================================================
  var DB = function(collectionName, query, options) {

    var set;

    if (typeof collectionName === 'string') {
      var collection = collections[collectionName];      
      if (!collection) {        
        if (!pendingQueries[collectionName])
          pendingQueries[collectionName] = [];
        if (!sets[collectionName])
          sets[collectionName] = [];
        if (query || options) {
          set = new Set(null, query, options, pendingQueries[collectionName]);
        } else {
          set = Collections[collectionName] =
              new Collection(null, pendingQueries[collectionName]);
        }
        sets[collectionName].push(set);        
        if (!collectionsInit[collectionName]) {
          var collectionHandler = function(err, collection) {
            if (err) throw err;
            collectionReady(collection, collectionName);
          }
          if (db) {
            db.collection(collectionName, collectionHandler);
          } else {
            new mongo.Db(dbName, new mongo.Server(host, port, {}), {
              native_parser: false
            }).open(function(err, openDb) {
              if (err) throw err;
              db = openDb;
              db.collection(collectionName, collectionHandler);
            });
          }  
          collectionsInit[collectionName] = true;
        }        
      } else {
        set = (query || options) ?
          new Set(collection, query, options) :
          Collections[collectionName];          
      }
      return set;
    }

    var i, queries, callback, errorHandler, returnObj;

    if (typeof arguments[1] === 'object' || Array.isArray(queries = arguments[0])) {      
      if (queries) {
        callback = arguments[1];
        errorHandler = arguments[2];
        returnObj = arguments[3];
      } else {
        queries = [];
        while (arguments[i] && typeof arguments === 'object')
          queries.push(arguments[i++]);
        callback = arguments[i];
        errorHandler = arguments[i + 1];
        returnObj = arguments[i + 2];
      }
      returnObj || (returnObj = {});
      for (i = 0; i < queries.length; i++) {
        processQuery(DB, queries[i], callback, errorHandler,
            i, returnObj, {lock: queries.length});
      }
    } else {
      processQuery(DB, arguments[0], arguments[1], arguments[2]);
    }

    return queryCount.value++;
    
  }

  //============================================================================
  var collectionReady = function(collection, collectionName) {
    var collectionQueries = pendingQueries[collectionName];
    var collectionSets = sets[collectionName];
    var i, len, q, set;
    for (i = 0, len = collectionQueries.length; i < len; i++) {
      q = collectionQueries[i];
      collection[q.pop()].apply(collection, q);
    }
    for (i = 0, len = collectionSets.length; i < len; i++) {
      set = collectionSets[i];
      set.collection = collection;
      set.pendingQueries.length = 0;
      delete set.pendingQueries;
    }
    collections[collectionName] = collection;
    collectionQueries.length = 0;
    collectionSets.length = 0;
    delete pendingQueries[collectionName];
    delete sets[collectionName];
    delete collectionsInit[collectionName];
  }

  //============================================================================
  DB.wait = function() {
    var len = arguments.length;
    var callback = arguments[len - 1];    
    var wait = {value: 0};
    var arg = [];
    var i, qf;
    for (i = 0; i < len - 1; i++) {
      qf = arguments[i];
      if (qf.ready) {
        arg[i] = qf.arg;
      } else {
        wait.value++;
        qf.callback({run: callback, i: i, wait: wait, arg: arg});
      }
    }
    if (!wait.value)
      callback(arg);    
  }

  //============================================================================
  return DB;

}

function processQuery(db, q, callback) {

  var collection, query, update, options;

  if (q.collection) {
    collection = q.collection;
    delete q.collection;
  } else if (q.coll) {
    collection = q.coll;
    delete q.coll;
  }

  if (q.find) {
    query = q.find;
    delete q.find;
    return db(collection, query, q).all(callback);
  }

  if (q.findOne) {
    query = q.findOne;
    delete q.findOne;
    return db(collection, query, q).one(callback);
  }

  if (q.iterate) {
    query = q.iterate;
    delete q.iterate;
    return db(collection, query, q).iterate(callback);
  }

  if ((update = q.update || getUpdates(q))) {
    options = {};
    if (q.upsert != null)
      options.upsert = q.upsert;
    if (q.multi != null)
      options.multi = q.multi;
    if (q.element) {
      options.multi = false;
      return db(collection, q.element).update(update, options, callback);
    }
    if (q.elements) {
      options.multi = true;
      return db(collection, q.elements).update(update, options, callback);
    }
  }

  if (q.insert)
    return db(collection).insert(q.insert, callback);

  if (q.remove)
    return db(collection).remove(q.remove, callback);

  if (q.save)
    return db(collection).save(q.remove, callback);

  throw new Error('wrong db query');
 
}

var getUpdates = function() {
  var updateAttrs = [
    'inc', 'set', 'unset', 'push', 'pushAll', 'addToSet', 'pop',
    'pull', 'pullAll', 'rename', 'bit'
  ];
  return function(q) {
    var updates;
    for (var u in q) {
      if (updateAttrs.indexOf(u) !== -1) {
        updates = updates || {};
        updates['$' + u] = q[u];
      }
    }
    return updates;
  }
}();