var RequestFuture = require('./RequestFuture');
var ObjectID = require('mongodb').BSONPure.ObjectID;

//==============================================================================
function Collection(name, db) {
  this.name = name;
  this.db = db;
  this.connection = null;
  this.pendingRequests = [];
  this.initialized = false;
}

//==============================================================================
Collection.prototype.find = function(query, fields, options, callback) {

  var future;

  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (typeof fields === 'function') {
    callback = fields;
    fields = null;
  } else if (typeof query === 'function') {
    callback = query;
    query = {};
  }

  if (typeof options === 'number')
    options = {limit: options};
  else
    options || (options = {});

  if (Array.isArray(fields)) {
    options.fields = {};
    for (var i = 0; i < fields.length; i++)
      options.fields[fields[i]] = 1;
  } else {
    options.fields = fields;
  }

  query || (query = {});

  if (typeof query._id === 'string')
    query._id = new ObjectID(query._id);

  future = new RequestFuture(callback);

  callback = function(err, cursor) {
    if (err) {
      future.notifyErrorHandlers(err);
    } else {
      cursor.toArray(function(err, elts) {
        err ?
          future.notifyErrorHandlers(err) :
          future.notifyCallbacks(elts);
      });
    }
  }

  if (!this.initialized && this.db)
    this.init();
  
  this.connection ?
    this.connection.find(query, options, callback) :
    this.pendingRequests.push([query, options, callback, 'find']);

  return future;

}

//==============================================================================
Collection.prototype.findOne = function(query, fields, options, callback) {

  var future;

  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (typeof fields === 'function') {
    callback = fields;
    fields = null;
  } else if (typeof query === 'function') {
    callback = query;
    query = {};
  }

  if (typeof options === 'number')
    options = {limit: options};
  else
    options || (options = {});

  if (Array.isArray(fields)) {
    options.fields = {};
    for (var i = 0; i < fields.length; i++)
      options.fields[fields[i]] = 1;
  } else {
    options.fields = fields;
  }

  query || (query = {});
  
  if (typeof query._id === 'string')
    query._id = new ObjectID(query._id);

  future = new RequestFuture(callback);

  callback = function(err, elt) {
    err ?
      future.notifyErrorHandlers(err) :
      future.notifyCallbacks(elt);
  }

  if (!this.initialized && this.db)
    this.init();

  this.connection ?
    this.connection.findOne(query, options, callback) :
    this.pendingRequests.push([query, options, callback, 'findOne']);

  return future;

}

//==============================================================================
Collection.prototype.findEach = function(query, fields, options, callback) {

  var future;

  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (typeof fields === 'function') {
    callback = fields;
    fields = null;
  } else if (typeof query === 'function') {
    callback = query;
    query = {};
  }

  if (typeof options === 'number')
    options = {limit: options};
  else
    options || (options = {});

  if (Array.isArray(fields)) {
    options.fields = {};
    for (var i = 0; i < fields.length; i++)
      options.fields[fields[i]] = 1;
  } else {
    options.fields = fields;
  }

  query || (query = {});
  
  if (typeof query._id === 'string')
    query._id = new ObjectID(query._id);

  future = new RequestFuture(callback);

  callback = function(err, cursor) {
    if (err) {
      future.notifyErrorHandlers(err);
    } else {
      cursor.each(function(err, elt) {
        err ?
          future.notifyErrorHandlers(err) :
          future.notifyCallbacks(elt);
      });
    }
  }

  if (!this.initialized && this.db)
    this.init();

  this.connection ?
    this.connection.find(query, options, callback) :
    this.pendingRequests.push([query, options, callback, 'find']);

  return future;

}

//==============================================================================
Collection.prototype.insert = function(elements, callback) {

  var elt, elts, lastArg, len, future, i;

  if (Array.isArray(elements)) {
    elts = elements;
  } else {
    lastArg = arguments[arguments.length - 1];
    len = arguments.length;
    if (lastArg === true || typeof lastArg === 'function') {
      future = new RequestFuture(lastArg);
      len--;
    }
    elts = [];
    for (i = 0; i < len; i++)
      elts.push(arguments[i]);
  }

  if (future) {
    callback = function(err, elts) {
      err ?
        future.notifyErrorHandlers(err) :
        future.notifyCallbacks(elts.length > 1 ? elts : elts[0]);
    }
  }

  if (!this.initialized && this.db)
    this.init();

  if (this.connection) {
    for (i = 0; elt = elts[i]; i++) {
      if (typeof elt._id === 'string')
        elt._id = new ObjectID(elt._id);
    }
    callback ?
      this.connection.insert(elts, {safe: true}, callback) :
      this.connection.insert(elts);
  } else {
    this.pendingRequests.push(callback ?
      [elts, {safe: true}, callback, 'insert'] :
      [elts, 'insert']
    );
  }

  return future;
  
}

//==============================================================================
Collection.prototype.remove = function(query, callback) {

  var future;

  if (callback) {
    future = new RequestFuture(callback);
    callback = function(err) {
      err ?
        future.notifyErrorHandlers(err) :
        future.notifyCallbacks();
    }
  }

  query || (query = {});
  
  if (typeof query._id === 'string')
    query._id = new ObjectID(query._id);

  if (!this.initialized && this.db)
    this.init();

  if (this.connection) {
    callback ?
      this.connection.remove(query, {safe: true}, callback) :
      this.connection.remove(query, null, null);
  } else {
    this.pendingRequests.push(callback ?
      [query, {safe: true}, callback, 'remove'] :
      [query, null, null, 'remove']
    );
  }

  return future;
  
}

//==============================================================================
Collection.prototype.save = function(element, callback) {

   var future;

   if (callback) {
    future = new RequestFuture(callback);
    callback = function(err, element) {
      err ?
        future.notifyErrorHandlers(err) :
        future.notifyCallbacks(element);
    }
  }

  if (!this.initialized && this.db)
    this.init();

  if (this.connection) {
    if (typeof element._id === 'string')
      element._id = new ObjectID(element._id);
    callback ?
      this.connection.save(element, callback) :
      this.connection.save(element);
  } else {
    this.pendingRequests.push(callback ?
      [element, callback, 'save'] :
      [element, 'save']
    );
  }

  return future;

}

//==============================================================================
Collection.prototype.update = function(query, newObj, upsert, multi, callback) {

  var future, options;

  if (typeof query._id === 'string')
    query._id = new ObjectID(query._id);

  if (typeof upsert === 'function') {
    callback = upsert;
    upsert= false;
    multi = false;
  } else if (typeof multi === 'function') {
    callback = multi;
    multi = false;
  }

  if (callback) {
    future = new RequestFuture(callback);
    callback = function(err) {
      err ?
        future.notifyErrorHandlers(err) :
        future.notifyCallbacks();
    }
    options = {safe: true};
  }

  options || (options = {});
  options.upsert = upsert;
  options.multi = multi;

  if (!this.initialized && this.db)
    this.init();

  if (this.connection) {
    callback ?
      this.connection.update(query, newObj, options, callback) :
      this.connection.update(query, newObj, options);
  } else {
    this.pendingRequests.push(callback ?
      [query, newObj, options, callback, 'update'] :
      [query, newObj, options, 'update']
    );
  }

  return future;
  
}

//==============================================================================
Collection.prototype.count = function(query, callback) {
  
  var future;
  
  if (typeof query === 'function') {
    callback = query;
    query = {};
  }

  future = new RequestFuture(callback);

  callback = function(err, count) {
    err ?
      future.notifyErrorHandlers(err) :
      future.notifyCallbacks(count);
  }
  
  if (!this.initialized && this.db)
    this.init();

  this.connection ?
    this.connection.count(query, callback) :
    this.pendingRequests.push([query, callback, 'count']);

  return future;
  
}

//==============================================================================
Collection.prototype.init = function() {
  var self = this;
  this.db.collection(self.name, function(err, connection) {
    if (err) throw err;
    for (var i = 0, request; request = self.pendingRequests[i]; i++)
      connection[request.pop()].apply(connection, request);
    self.connection = connection;
    delete self.pendingRequests;
  });
  this.initialized = true;
}

//==============================================================================
module.exports = Collection;