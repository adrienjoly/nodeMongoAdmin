var DEFAULT_MAX_CACHE_SIZE = 256 * 1024 * 1024;
var DEFAULT_MAX_BUFFER_SIZE = 512 * 1024;
var DEFAULT_EXPIRATION_DELAY = 24 * 3600 * 1000;
var DEFAULT_TIME_UNIT = 3600 * 1000;
var DEFAULT_RESIZE_FACTOR = 0.5;

//==============================================================================
function Cache(options) {
  options = options || {};
  this.data = {};
  this.numElement = 0;
  this.numAccess = 0;
  this.size = 0;
  this.maxCacheSize = options.maxCacheSize || DEFAULT_MAX_CACHE_SIZE;
  this.maxBufferSize = options.maxBufferSize || DEFAULT_MAX_BUFFER_SIZE;
  this.expirationDelay = options.expirationDelay || DEFAULT_EXPIRATION_DELAY;
  this.timeUnit = options.timeUnit || DEFAULT_TIME_UNIT;
  this.resizeFactor = options.resizeFactor || DEFAULT_RESIZE_FACTOR;  
}

//==============================================================================
Cache.prototype.put = function(key, buffer, mtime) {
  var len = buffer.length;
  if (len > this.maxBufferSize)
    throw new Error('max buffer size is ' + this.maxBufferSize);
  if (this.size + len > this.maxCacheSize)
    this.resize();    
  if (this.data[key]) {
    this.size += len - this.data[key].buffer.length;
  } else {
    this.size += len;
    this.numElement++;
  }
  this.data[key] = {buffer: buffer, cacheTime: Date.now(), numAccess: 1};
  if (mtime)
    this.data[key].mtime = mtime;
}

//==============================================================================
Cache.prototype.get = function(key) {
  var data = this.data[key];
  if (data) {
    this.numAccess++;
    data.numAccess++;
    return data;
  }
  return null;
}

//==============================================================================
Cache.prototype.remove = function(key) {
  var data = this.data[key];
  var len = data.buffer.length;
  if (data) {
    this.size -= len;
    this.numElement--;
    delete this.data[key];
    return len;
  }
  return 0;
}

//==============================================================================
Cache.prototype.removeExpiredBuffers = function(expirationTime) {
  var numBytesFreed = 0;
  for (var key in this.data)
    if (this.data[key].cacheTime < expirationTime)
      numBytesFreed += this.remove(key);  
  return numBytesFreed;
}

//==============================================================================
Cache.prototype.resize = function() {

  var limitSize = Math.floor(this.maxCacheSize * this.resizeFactor);
  var now = Date.now();
  var expirationTime = now - this.expirationDelay;

  this.removeExpiredBuffers(expirationTime);

  if (this.size <= limitSize)
    return;

  var keys = [null];
  for (var key in this.data)
    keys.push(key);

  var self = this;  
  var N = keys.length - 1;
  var v = [];
  var x = [];    

  var knapsack = function(i, l) {      
    var data = self.data[keys[i]];
    var value, t;
    if (i === 0 || l === 0)
      return 0;
    if (data.buffer.length > l)
      return 0;    
    if (!v[i])      
      v[i] = [];    
    if ((value = v[i][l])) 
      return value;
    t = Math.ceil((now - data.cacheTime) / self.timeUnit) || 1;
    value = Math.max(
      knapsack(i - 1, l),
      knapsack(i - 1, l - data.buffer.length) + data.numAccess / t
    );
    v[i][l] = value;
    return value;
  }
  
  var processResult = function(i, l) {
    if (i === 0 || l === 0)
      return;
    if (self.data[keys[i]].buffer.length > l) {
      processResult(i - 1, l);
      return;
    }
    if (i === 1) {
      x[i] = 1;
      return;
    }
    if (v[i - 1][l] === v[i][l]) {
      processResult(i - 1, l);
    } else {
      x[i] = 1;
      processResult(i - 1, l - self.data[keys[i]].buffer.length);
    }
  }
  
  knapsack(N, limitSize);
  processResult(N , limitSize);  

  for (var i = 1; i <= N; i++)
    if (x[i] !== 1)
      this.remove(keys[i]);

}

//==============================================================================
module.exports = Cache;