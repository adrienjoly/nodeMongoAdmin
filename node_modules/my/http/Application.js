var fs = require('fs');
var util = require('util');
var path = require('path');
var url = require('url');
var http = require('http');
var querystring = require('querystring');

var my = require('../');
var extendResponse = require('./Response').extend;
var AppendBuffer = require('../util').Buffer;

//============================================================================
// Class Application
var aa = exports.Application = my.Class(http.Server, {

  constructor: function(appDir, devMode) {

    var self = this;

    http.Server.call(this, function(request, response) {
      try {
        _checkRoutes(self, request, response)
      } catch (e) {
        _processError(self, e, response);
      }      
    });

    this.models = {};
    this.views = {};
    this.controllers = {};

    this._devMode = devMode;

    this._modelsDir = appDir + '/app/models';
    this._viewsDir = appDir + '/app/views';
    this._controllersDir = appDir + '/app/controllers';
    this._publicDir = appDir + '/public';

    this._configFile = appDir + '/config/app.conf';
    this._routeFile = appDir + '/config/app.route';

    this._modulesModifyDates = {};
    this._routes = {
      GET: [], POST: [], HEAD: [], OPTIONS: [],
      CONNECT: [], TRACE: [], PUT: [], DELETE: []
    };

    this._port = null;
    this._queryStringInJSON = null;
    this._maxCacheSize = null;
    this._readBufferMaxSize = null;
    this._writeBuffer = null;

    _configure(this);
    _updateModules(this);
    _updateRoutes(this);    

  },

  start: function() {
    this._isRunning = true;
    this.listen(this._port);
    util.log('Server running at http://127.0.0.1:' + this._port + '/');
  },

  stop: function() {
    if (this._isRunning) {
      this.close();
      this._isRunning = false;
    }
  },

  route: function(request, controller) {

    var routes = this._routes.GET;
    var route = {controller: controller, hasQuery: request.contains('?')};
    var regexp = /(GET|POST|HEAD|OPTIONS|CONNECT|TRACE|PUT|DELETE)\s*(\/\S+)/;
    var requestParams, requestParam, requestParamSplit;

    if (regexp.test(request)) {
      routes = this._routes[RegExp.$1];
      request = RegExp.$2;
    }

    requestParams = request.match(/\{[\w\$]+(\:\w+)?\}/g);
    if (requestParams) {
      route.requestParamNames = [];
      route.requestParamTypes = [];
      for (var i = 0; i < requestParams.length; i++) {
        requestParam = requestParams[i];
        requestParamSplit = requestParam.substring(1, requestParam.length - 1);
        requestParamSplit = requestParamSplit.split(':');
        if (requestParamSplit.length > 1) {
          if (requestParamSplit[1] === 'int')
            request = request.replace(requestParam, '(\\d+)');
          else if (requestParamSplit[1] === 'boolean')
            request = request.replace(requestParam, '(true|false)');
          else
            request = request.replace(requestParam, '(\\w+)');
        } else {
          request = request.replace(requestParam, '(\\w+)');
        }
        route.requestParamNames.push(requestParamSplit[0]);
        route.requestParamTypes.push(requestParamSplit[1] || 'string');
      }
    }

    route.pattern = new RegExp("^" + request.replace(/[\/\.\?]/g, function(s) {
      return '\\' + s;
    }) + '$');
    routes.push(route);

    return this;

  }

});

//==============================================================================
// private methods
function _configure(self) {

  var config = getConfigObject(self._configFile, '=');

  self._jsonFormatQueryString = config.jsonFormatQueryString === 'true';
  self._maxCacheSize = parseInt(config.maxCacheSize);
  self._readBufferMaxSize = parseInt(config.readBufferMaxSize);

  var port = parseInt(config.port);
  if (port !== self._port) {
    self._port = port;
    if (self._isRunning) {
      self.stop();
      self.start();
    }
  }

  var writeBufferSize = parseInt(config.writeBufferSize); 
  if (!self._writeBuffer || writeBufferSize !== self._writeBuffer.length)
    self._writeBuffer = new AppendBuffer(writeBufferSize);
  
  self.config = config;
}


function _updateModules(self) {
  var modifyDates = self._modulesModifyDates;
  loadModules(self._modelsDir, self.models, modifyDates, 'm');
  loadModules(self._viewsDir, self.views, modifyDates, 'v');
  loadModules(self._controllersDir, self.controllers, modifyDates, 'c');
}

function _updateRoutes(self) {
  for (var r in self._routes)
    self._routes[r].length = 0;
  var routes = getRouteArray(self._routeFile);
  for (var i = 0, route; route = routes[i]; i++) {
    self.route(route.pattern, getObjectFromPath(route.controller, self, '.'));
  }
}

function _renderFile(self, file, fileSize, response) { 
  var fileExtension = path.extname(file);
  var bufferSize = Math.min(fileSize, self._readBufferMaxSize);
  response.writeHead(200, Headers[fileExtension] || Headers['default']);
  fs.createReadStream(file, {bufferSize: bufferSize})
    .on('data', function(data) {response.write(data);})
    .on('end', function() {response.end();});
}


//==============================================================================
// process request
function _checkRoutes(self, request, response) {

  if (self._devMode) {
    _updateModules(self);
    _updateRoutes(self);
  }

  var routes = self._routes[request.method];
  var urlObj = url.parse(request.url);
  var path = urlObj.pathname;
  var query = urlObj.query;  
  var route, routeMatch, requestParams;

  if (routes) {
    for (var i = 0; route = routes[i]; i++) {
      routeMatch = (route.hasQuery ? request.url : path).match(route.pattern);
      if (routeMatch) {
        extendResponse(response, self._writeBuffer);
        requestParams = getRequestParams(route, routeMatch);
        route.controller.call(self, request, requestParams, response);
        return;
      }
    }
  }  

  if (query) {
    try {
      requestParams = self._jsonFormatQueryString ?
        JSON.parse(decodeURI(query)) :
        querystring.parse(query);
    } catch(e) {}
  }

  _checkPublicControllers(self, request, requestParams, response);

}

function _checkPublicControllers(self, request, requestParams, response) {
  var pathname = 'public' + url.parse(request.url).pathname;
  var controller = getObjectFromPath(pathname, self.controllers, '/');
  if (controller) {
    extendResponse(response, self._writeBuffer);
    controller.call(self, request, requestParams, response);
  } else {
    _checkPublicViews(self, request, requestParams, response);
  }
}

function _checkPublicViews(self, request, requestParams, response) {
  var pathname = 'public' + url.parse(request.url).pathname;
  var view = getObjectFromPath(pathname, self.views, '/');
  if (view) {
    var model = getObjectFromPath(pathname, self.models, '/');
    var data = typeof model === 'function' ?
      model(requestParams) : requestParams;
    extendResponse(response, self._writeBuffer);
    response.render(view, data);
  } else
    _checkPublicFiles(self, request, requestParams, response);
}

function _checkPublicFiles(self, request, requestParams, response) {
  var urlObj = url.parse(request.url);
  var pathname = self._publicDir + urlObj.pathname;
  fs.stat(pathname, function(error, stats) {
    if (error) {
      response.end('error 404 not found');
    } else if (!stats.isFile()) {
      if (!pathname.endsWith('/index.html')) {
        request.url = urlObj.pathname + 'index.html' 
          + (urlObj.search ? urlObj.search : '');
        _checkRoutes(self, request, response);
      } else {
        response.end('error 404 not found');
      }
    } else {      
      _renderFile(self, pathname, stats.size, response);
    }
  });
}

function _processError(self, e, response) {
  response.end(e.stack);
}


//==============================================================================
// inner functions
function getConfigObject(file) {
  var fileText = fs.readFileSync(file, 'utf8');
  var lines = fileText.split('\n');
  var configObject = {};
  var line;
  for (var i = 0, len = lines.length; i < len; i++) {
    line = lines[i].split('=');
    if (line.length >= 2)
      configObject[line[0].trim()] = line[1].trim();
  }
  return configObject;
}

function getRouteArray(file) {
  var fileText = fs.readFileSync(file, 'utf8');
  var lines = fileText.split('\n');
  var routeArray = [];
  var line;
  for (var i = 0, len = lines.length; i < len; i++) {
    line = lines[i].split('->');
    if (line.length >= 2)
      routeArray.push({pattern: line[0].trim(), controller: line[1].trim()});
  }
  return routeArray;
}

function getObjectFromPath(path, root, separator) {
  if (!path) return null;
  var obj = root;
  path = path.split(separator);
  for (var i = 0; i < path.length && obj !== undefined; i++)
    obj = obj[path[i]];
  return obj;
}

function getRequestParams(route, routeMatch) {
  var names = route.requestParamNames;
  var types = route.requestParamTypes;
  var name, type, requestParams;
  if (names) {
    requestParams = {};
    for (var j = 0; j < names.length; j++) {
      name = names[j];
      type = types[j];
      if (type === 'int')
        requestParams[name] = parseInt(routeMatch[j + 1]);
      else if (type === 'boolean')
        requestParams[name] = routeMatch[j + 1] === 'true';
      else if (type === 'string')
        requestParams[name] = routeMatch[j + 1];
      else if (type === 'Object')
        requestParams[name] = JSON.parse(routeMatch[j + 1]);
    }
  }
  return requestParams;
}

function loadModules(dir, modulesObj, lastModifyDates, type) {
  var files = fs.readdirSync(dir);
  var file, stats, name, modulePath, modifyDate;
  for (var i = 0; file = files[i]; i++) {
    modulePath = dir + '/' + file;
    stats = fs.statSync(modulePath);
    if (stats.isFile()) {
      if (file.endsWith('.js')) {
        name = path.basename(file, '.js');
        modifyDate = new Date(stats.mtime);
        if (!modulesObj[name] || modifyDate > lastModifyDates[file]) {
          if (modulesObj[name])
            require.cache[modulePath] = null;          
          if (type === 'm')
            modulesObj[name] = require(modulePath).model;
          else if (type === 'v')
            modulesObj[name] = require(modulePath).view;
          else if (type === 'c')
            modulesObj[name] = require(modulePath).controller;          
          lastModifyDates[file] = modifyDate;
        }
      }
    } else {
      modulesObj[file] = modulesObj[file] || {};
      lastModifyDates[file] = lastModifyDates[file] || {};
      loadModules(modulePath, modulesObj[file], lastModifyDates[file], type);
    }
  }
}

var Headers = {
  '.html': {
    'content-type': 'text/html'
  },
  '.css': {
    'content-type': 'text/css'
  },
  '.txt': {
    'content-type': 'text/plain'
  },
  '.png': {
    'content-type': 'image/png',
    'transfer-encoding': 'chunked'
  },
  '.gif': {
    'content-type': 'image/gif',
    'transfer-encoding': 'chunked'
  },
  '.jpg': {
    'content-type': 'image/jpeg',
    'transfer-encoding': 'chunked'
  },
  '.bmp': {
    'content-type': 'image/bmp',
    'transfer-encoding': 'chunked'
  },
  '.ico': {
    'content-type': 'image/x-icon',
    'transfer-encoding': 'chunked'
  },
  '.webm': {
    'content-type': 'video/webm',
    'transfer-encoding': 'chunked'
  },
  '.ogv': {
    'content-type': 'video/ogg',
    'transfer-encoding': 'chunked'
  },
  '.mp4': {
    'content-type': 'video/mp4',
    'transfer-encoding': 'chunked'
  },
  '.xml': {
    'content-type': 'application/xml'
  },
  '.js': {
    'content-type': 'application/x-javascript'
  },
  '.swf': {
    'content-type': 'application/x-shockwave-flash',
    'transfer-encoding': 'chunked'
  },
  'default': {
    'content-type': 'application/octet-stream'
  }
};
